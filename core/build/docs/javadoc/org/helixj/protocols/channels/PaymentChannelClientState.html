<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="fr">
<head>
<!-- Generated by javadoc -->
<title>PaymentChannelClientState (core 0.15.8 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.helixj.protocols.channels, class: PaymentChannelClientState">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":10,"i1":10,"i2":10,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":10,"i11":6,"i12":6,"i13":10,"i14":10,"i15":6,"i16":10,"i17":10,"i18":6,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.helixj.protocols.channels</a></div>
<h1 title="Class PaymentChannelClientState" class="title">Class PaymentChannelClientState</h1>
</div>
<div class="contentContainer">
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">org.helixj.protocols.channels.PaymentChannelClientState</div>
</div>
<section class="description">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="PaymentChannelV1ClientState.html" title="class in org.helixj.protocols.channels">PaymentChannelV1ClientState</a></code>, <code><a href="PaymentChannelV2ClientState.html" title="class in org.helixj.protocols.channels">PaymentChannelV2ClientState</a></code></dd>
</dl>
<hr>
<pre>public abstract class <span class="typeNameLabel">PaymentChannelClientState</span>
extends java.lang.Object</pre>
<div class="block"><p>A payment channel is a method of sending money to someone such that the amount of money you send can be adjusted
 after the fact, in an efficient manner that does not require broadcasting to the network. This can be used to
 implement micropayments or other payment schemes in which immediate settlement is not required, but zero trust
 negotiation is. Note that this class only allows the amount of money sent to be incremented, not decremented.</p>

 <p>This class has two subclasses, <a href="PaymentChannelV1ClientState.html" title="class in org.helixj.protocols.channels"><code>PaymentChannelV1ClientState</code></a> and <a href="PaymentChannelV2ClientState.html" title="class in org.helixj.protocols.channels"><code>PaymentChannelV2ClientState</code></a> for
 protocols version 1 and 2.</p>

 <p>This class implements the core state machine for the client side of the protocol. The server side is implemented
 by <a href="PaymentChannelServerState.html" title="class in org.helixj.protocols.channels"><code>PaymentChannelServerState</code></a> and <a href="PaymentChannelClientConnection.html" title="class in org.helixj.protocols.channels"><code>PaymentChannelClientConnection</code></a> implements a network protocol
 suitable for TCP/IP connections which moves this class through each state. We say that the party who is sending funds
 is the <i>client</i> or <i>initiating party</i>. The party that is receiving the funds is the <i>server</i> or
 <i>receiving party</i>. Although the underlying Bitcoin protocol is capable of more complex relationships than that,
 this class implements only the simplest case.</p>

 <p>A channel has an expiry parameter. If the server halts after the multi-signature contract which locks
 up the given value is broadcast you could get stuck in a state where you've lost all the money put into the
 contract. To avoid this, a refund transaction is agreed ahead of time but it may only be used/broadcast after
 the expiry time. This is specified in terms of block timestamps and once the timestamp of the chain chain approaches
 the given time (within a few hours), the channel must be closed or else the client will broadcast the refund
 transaction and take back all the money once the expiry time is reached.</p>

 <p>To begin, the client calls <a href="#initiate()"><code>initiate()</code></a>, which moves the channel into state
 INITIATED and creates the initial multi-sig contract and refund transaction. If the wallet has insufficient funds an
 exception will be thrown at this point. Once this is done, call
 <a href="PaymentChannelV1ClientState.html#getIncompleteRefundTransaction()"><code>PaymentChannelV1ClientState.getIncompleteRefundTransaction()</code></a> and pass the resultant transaction through to the
 server. Once you have retrieved the signature, use <a href="PaymentChannelV1ClientState.html#provideRefundSignature(byte%5B%5D,org.spongycastle.crypto.params.KeyParameter)"><code>PaymentChannelV1ClientState.provideRefundSignature(byte[], KeyParameter)</code></a>.
 You must then call <a href="#storeChannelInWallet(org.helixj.core.Sha256Hash)"><code>storeChannelInWallet(Sha256Hash)</code></a> to store the refund transaction
 in the wallet, protecting you against a malicious server attempting to destroy all your coins. At this point, you can
 provide the server with the multi-sig contract (via <a href="PaymentChannelV1ClientState.html#getContract()"><code>PaymentChannelV1ClientState.getContract()</code></a>) safely.
 </p></div>
</section>
<section class="summary">
<ul class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li class="blockList">
<section class="nestedClassSummary"><a id="nested.class.summary">
<!--   -->
</a>
<h2>Nested Class Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="PaymentChannelClientState.IncrementedPayment.html" title="class in org.helixj.protocols.channels">PaymentChannelClientState.IncrementedPayment</a></span></code></th>
<td class="colLast">
<div class="block">Container for a signature and an amount that was sent.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="PaymentChannelClientState.State.html" title="enum in org.helixj.protocols.channels">PaymentChannelClientState.State</a></span></code></th>
<td class="colLast">
<div class="block">The different logical states the channel can be in.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- =========== FIELD SUMMARY =========== -->
<li class="blockList">
<section class="fieldSummary"><a id="field.summary">
<!--   -->
</a>
<h2>Field Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="StateMachine.html" title="class in org.helixj.protocols.channels">StateMachine</a>&lt;<a href="PaymentChannelClientState.State.html" title="enum in org.helixj.protocols.channels">PaymentChannelClientState.State</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#stateMachine">stateMachine</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected org.helixj.protocols.channels.StoredClientChannel</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#storedChannel">storedChannel</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#valueToMe">valueToMe</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li class="blockList">
<section class="constructorSummary"><a id="constructor.summary">
<!--   -->
</a>
<h2>Constructor Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(org.helixj.wallet.Wallet,org.helixj.core.ECKey,org.helixj.core.ECKey,org.helixj.core.Coin,long)">PaymentChannelClientState</a></span>&#8203;(<a href="../../wallet/Wallet.html" title="class in org.helixj.wallet">Wallet</a>&nbsp;wallet,
<a href="../../core/ECKey.html" title="class in org.helixj.core">ECKey</a>&nbsp;myKey,
<a href="../../core/ECKey.html" title="class in org.helixj.core">ECKey</a>&nbsp;serverKey,
<a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;value,
long&nbsp;expiryTimeInSeconds)</code></th>
<td class="colLast">
<div class="block">Creates a state object for a payment channel client.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="tableTab" onclick="show(4);">Abstract Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="tableTab" onclick="show(8);">Concrete Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#checkNotExpired()">checkNotExpired</a></span>()</code></th>
<td class="colLast">
<div class="block">Checks if the channel is expired, setting state to <a href="PaymentChannelClientState.State.html#EXPIRED"><code>PaymentChannelClientState.State.EXPIRED</code></a>, removing this channel from wallet
 storage and throwing an <code>IllegalStateException</code> if it is.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#disconnectFromChannel()">disconnectFromChannel</a></span>()</code></th>
<td class="colLast">
<div class="block">Sets this channel's state in <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a> to unopened so this channel can be reopened
 later.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#editContractSendRequest(org.helixj.wallet.SendRequest)">editContractSendRequest</a></span>&#8203;(<a href="../../wallet/SendRequest.html" title="class in org.helixj.wallet">SendRequest</a>&nbsp;req)</code></th>
<td class="colLast">
<div class="block">You can override this method in order to control the construction of the initial contract that creates the
 channel.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>abstract <a href="../../core/Transaction.html" title="class in org.helixj.core">Transaction</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getContract()">getContract</a></span>()</code></th>
<td class="colLast">
<div class="block">Gets the contract which was used to initialize this channel</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>protected abstract <a href="../../core/Transaction.html" title="class in org.helixj.core">Transaction</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getContractInternal()">getContractInternal</a></span>()</code></th>
<td class="colLast">
<div class="block">Gets the contract without changing the state machine</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>protected abstract <a href="../../script/Script.html" title="class in org.helixj.script">Script</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getContractScript()">getContractScript</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>protected abstract long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getExpiryTime()">getExpiryTime</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>abstract int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMajorVersion()">getMajorVersion</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>abstract <a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRefundTxFees()">getRefundTxFees</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the fees that will be paid if the refund transaction has to be claimed because the server failed to settle
 the channel properly.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>protected abstract <a href="../../script/Script.html" title="class in org.helixj.script">Script</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSignedScript()">getSignedScript</a></span>()</code></th>
<td class="colLast">
<div class="block">Gets the script that is signed.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code><a href="PaymentChannelClientState.State.html" title="enum in org.helixj.protocols.channels">PaymentChannelClientState.State</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getState()">getState</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>protected abstract com.google.common.collect.Multimap&lt;<a href="PaymentChannelClientState.State.html" title="enum in org.helixj.protocols.channels">PaymentChannelClientState.State</a>,&#8203;<a href="PaymentChannelClientState.State.html" title="enum in org.helixj.protocols.channels">PaymentChannelClientState.State</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getStateTransitions()">getStateTransitions</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>abstract <a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getTotalValue()">getTotalValue</a></span>()</code></th>
<td class="colLast">
<div class="block">Gets the total value of this channel (ie the maximum payment possible)</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code><a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getValueRefunded()">getValueRefunded</a></span>()</code></th>
<td class="colLast">
<div class="block">Gets the current amount refunded to us from the multisig contract (ie totalValue-valueSentToServer)</div>
</td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code><a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getValueSpent()">getValueSpent</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the amount of money sent on this channel so far.</div>
</td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>protected abstract <a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getValueToMe()">getValueToMe</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code><a href="PaymentChannelClientState.IncrementedPayment.html" title="class in org.helixj.protocols.channels">PaymentChannelClientState.IncrementedPayment</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#incrementPaymentBy(org.helixj.core.Coin,org.spongycastle.crypto.params.KeyParameter)">incrementPaymentBy</a></span>&#8203;(<a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;size,
org.spongycastle.crypto.params.KeyParameter&nbsp;userKey)</code></th>
<td class="colLast">
<div class="block">Updates the outputs on the payment contract transaction and re-signs it.</div>
</td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initiate()">initiate</a></span>()</code></th>
<td class="colLast">
<div class="block">Creates the initial multisig contract and incomplete refund transaction which can be requested at the appropriate
 time using <a href="PaymentChannelV1ClientState.html#getIncompleteRefundTransaction()"><code>PaymentChannelV1ClientState.getIncompleteRefundTransaction()</code></a> and
 <a href="PaymentChannelV1ClientState.html#getContract()"><code>PaymentChannelV1ClientState.getContract()</code></a>.</div>
</td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>abstract void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initiate(org.spongycastle.crypto.params.KeyParameter)">initiate</a></span>&#8203;(org.spongycastle.crypto.params.KeyParameter&nbsp;userKey)</code></th>
<td class="colLast">
<div class="block">Creates the initial multisig contract and incomplete refund transaction which can be requested at the appropriate
 time using <a href="PaymentChannelV1ClientState.html#getIncompleteRefundTransaction()"><code>PaymentChannelV1ClientState.getIncompleteRefundTransaction()</code></a> and
 <a href="PaymentChannelV1ClientState.html#getContract()"><code>PaymentChannelV1ClientState.getContract()</code></a>.</div>
</td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initWalletListeners()">initWalletListeners</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isSettlementTransaction(org.helixj.core.Transaction)">isSettlementTransaction</a></span>&#8203;(<a href="../../core/Transaction.html" title="class in org.helixj.core">Transaction</a>&nbsp;tx)</code></th>
<td class="colLast">
<div class="block">Returns true if the tx is a valid settlement transaction.</div>
</td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#storeChannelInWallet(org.helixj.core.Sha256Hash)">storeChannelInWallet</a></span>&#8203;(<a href="../../core/Sha256Hash.html" title="class in org.helixj.core">Sha256Hash</a>&nbsp;id)</code></th>
<td class="colLast">
<div class="block">Stores this channel's state in the wallet as a part of a <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a> wallet
 extension and keeps it up-to-date each time payment is incremented.</div>
</td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#updateChannelInWallet()">updateChannelInWallet</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#watchCloseConfirmations()">watchCloseConfirmations</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inheritedList">
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a><code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<li class="blockList">
<section class="fieldDetails"><a id="field.detail">
<!--   -->
</a>
<h2>Field Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="valueToMe">valueToMe</a></h3>
<div class="memberSignature"><span class="modifiers">protected</span>&nbsp;<span class="returnType"><a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></span>&nbsp;<span class="memberName">valueToMe</span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="stateMachine">stateMachine</a></h3>
<div class="memberSignature"><span class="modifiers">protected final</span>&nbsp;<span class="returnType"><a href="StateMachine.html" title="class in org.helixj.protocols.channels">StateMachine</a>&lt;<a href="PaymentChannelClientState.State.html" title="enum in org.helixj.protocols.channels">PaymentChannelClientState.State</a>&gt;</span>&nbsp;<span class="memberName">stateMachine</span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="storedChannel">storedChannel</a></h3>
<div class="memberSignature"><span class="modifiers">protected</span>&nbsp;<span class="returnType">org.helixj.protocols.channels.StoredClientChannel</span>&nbsp;<span class="memberName">storedChannel</span></div>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li class="blockList">
<section class="constructorDetails"><a id="constructor.detail">
<!--   -->
</a>
<h2>Constructor Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="&lt;init&gt;(org.helixj.wallet.Wallet,org.helixj.core.ECKey,org.helixj.core.ECKey,org.helixj.core.Coin,long)">PaymentChannelClientState</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="memberName">PaymentChannelClientState</span>&#8203;(<span class="arguments"><a href="../../wallet/Wallet.html" title="class in org.helixj.wallet">Wallet</a>&nbsp;wallet,
<a href="../../core/ECKey.html" title="class in org.helixj.core">ECKey</a>&nbsp;myKey,
<a href="../../core/ECKey.html" title="class in org.helixj.core">ECKey</a>&nbsp;serverKey,
<a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;value,
long&nbsp;expiryTimeInSeconds)</span>
                          throws <span class="exceptions"><a href="../../core/VerificationException.html" title="class in org.helixj.core">VerificationException</a></span></div>
<div class="block">Creates a state object for a payment channel client. It is expected that you be ready to
 <a href="#initiate()"><code>initiate()</code></a> after construction (to avoid creating objects for channels which are
 not going to finish opening) and thus some parameters provided here are only used in
 <a href="#initiate()"><code>initiate()</code></a> to create the Multisig contract and refund transaction.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>wallet</code> - a wallet that contains at least the specified amount of value.</dd>
<dd><code>myKey</code> - a freshly generated private key for this channel.</dd>
<dd><code>serverKey</code> - a public key retrieved from the server used for the initial multisig contract</dd>
<dd><code>value</code> - how many satoshis to put into this contract. If the channel reaches this limit, it must be closed.</dd>
<dd><code>expiryTimeInSeconds</code> - At what point (UNIX timestamp +/- a few hours) the channel will expire</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../core/VerificationException.html" title="class in org.helixj.core">VerificationException</a></code> - If either myKey's pubkey or serverKey's pubkey are non-canonical (ie invalid)</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="isSettlementTransaction(org.helixj.core.Transaction)">isSettlementTransaction</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">isSettlementTransaction</span>&#8203;(<span class="arguments"><a href="../../core/Transaction.html" title="class in org.helixj.core">Transaction</a>&nbsp;tx)</span></div>
<div class="block">Returns true if the tx is a valid settlement transaction.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="initWalletListeners()">initWalletListeners</a></h3>
<div class="memberSignature"><span class="modifiers">protected</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">initWalletListeners</span>()</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="watchCloseConfirmations()">watchCloseConfirmations</a></h3>
<div class="memberSignature"><span class="modifiers">protected</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">watchCloseConfirmations</span>()</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getState()">getState</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="PaymentChannelClientState.State.html" title="enum in org.helixj.protocols.channels">PaymentChannelClientState.State</a></span>&nbsp;<span class="memberName">getState</span>()</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getStateTransitions()">getStateTransitions</a></h3>
<div class="memberSignature"><span class="modifiers">protected abstract</span>&nbsp;<span class="returnType">com.google.common.collect.Multimap&lt;<a href="PaymentChannelClientState.State.html" title="enum in org.helixj.protocols.channels">PaymentChannelClientState.State</a>,&#8203;<a href="PaymentChannelClientState.State.html" title="enum in org.helixj.protocols.channels">PaymentChannelClientState.State</a>&gt;</span>&nbsp;<span class="memberName">getStateTransitions</span>()</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getMajorVersion()">getMajorVersion</a></h3>
<div class="memberSignature"><span class="modifiers">public abstract</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName">getMajorVersion</span>()</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="initiate()">initiate</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">initiate</span>()
              throws <span class="exceptions"><a href="ValueOutOfRangeException.html" title="class in org.helixj.protocols.channels">ValueOutOfRangeException</a>,
<a href="../../core/InsufficientMoneyException.html" title="class in org.helixj.core">InsufficientMoneyException</a></span></div>
<div class="block">Creates the initial multisig contract and incomplete refund transaction which can be requested at the appropriate
 time using <a href="PaymentChannelV1ClientState.html#getIncompleteRefundTransaction()"><code>PaymentChannelV1ClientState.getIncompleteRefundTransaction()</code></a> and
 <a href="PaymentChannelV1ClientState.html#getContract()"><code>PaymentChannelV1ClientState.getContract()</code></a>. The way the contract is crafted can be adjusted by
 overriding <a href="#editContractSendRequest(org.helixj.wallet.SendRequest)"><code>editContractSendRequest(org.helixj.wallet.Wallet.SendRequest)</code></a>.
 By default unconfirmed coins are allowed to be used, as for micropayments the risk should be relatively low.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="ValueOutOfRangeException.html" title="class in org.helixj.protocols.channels">ValueOutOfRangeException</a></code> - if the value being used is too small to be accepted by the network</dd>
<dd><code><a href="../../core/InsufficientMoneyException.html" title="class in org.helixj.core">InsufficientMoneyException</a></code> - if the wallet doesn't contain enough balance to initiate</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="initiate(org.spongycastle.crypto.params.KeyParameter)">initiate</a></h3>
<div class="memberSignature"><span class="modifiers">public abstract</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">initiate</span>&#8203;(<span class="arguments">@Nullable
org.spongycastle.crypto.params.KeyParameter&nbsp;userKey)</span>
                       throws <span class="exceptions"><a href="ValueOutOfRangeException.html" title="class in org.helixj.protocols.channels">ValueOutOfRangeException</a>,
<a href="../../core/InsufficientMoneyException.html" title="class in org.helixj.core">InsufficientMoneyException</a></span></div>
<div class="block">Creates the initial multisig contract and incomplete refund transaction which can be requested at the appropriate
 time using <a href="PaymentChannelV1ClientState.html#getIncompleteRefundTransaction()"><code>PaymentChannelV1ClientState.getIncompleteRefundTransaction()</code></a> and
 <a href="PaymentChannelV1ClientState.html#getContract()"><code>PaymentChannelV1ClientState.getContract()</code></a>. The way the contract is crafted can be adjusted by
 overriding <a href="#editContractSendRequest(org.helixj.wallet.SendRequest)"><code>editContractSendRequest(org.helixj.wallet.Wallet.SendRequest)</code></a>.
 By default unconfirmed coins are allowed to be used, as for micropayments the risk should be relatively low.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>userKey</code> - Key derived from a user password, needed for any signing when the wallet is encrypted.
                  The wallet KeyCrypter is assumed.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="ValueOutOfRangeException.html" title="class in org.helixj.protocols.channels">ValueOutOfRangeException</a></code> - if the value being used is too small to be accepted by the network</dd>
<dd><code><a href="../../core/InsufficientMoneyException.html" title="class in org.helixj.core">InsufficientMoneyException</a></code> - if the wallet doesn't contain enough balance to initiate</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="editContractSendRequest(org.helixj.wallet.SendRequest)">editContractSendRequest</a></h3>
<div class="memberSignature"><span class="modifiers">protected</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">editContractSendRequest</span>&#8203;(<span class="arguments"><a href="../../wallet/SendRequest.html" title="class in org.helixj.wallet">SendRequest</a>&nbsp;req)</span></div>
<div class="block">You can override this method in order to control the construction of the initial contract that creates the
 channel. For example if you want it to only use specific coins, you can adjust the coin selector here.
 The default implementation does nothing.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getContract()">getContract</a></h3>
<div class="memberSignature"><span class="modifiers">public abstract</span>&nbsp;<span class="returnType"><a href="../../core/Transaction.html" title="class in org.helixj.core">Transaction</a></span>&nbsp;<span class="memberName">getContract</span>()</div>
<div class="block">Gets the contract which was used to initialize this channel</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="checkNotExpired()">checkNotExpired</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">checkNotExpired</span>()</div>
<div class="block">Checks if the channel is expired, setting state to <a href="PaymentChannelClientState.State.html#EXPIRED"><code>PaymentChannelClientState.State.EXPIRED</code></a>, removing this channel from wallet
 storage and throwing an <code>IllegalStateException</code> if it is.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="incrementPaymentBy(org.helixj.core.Coin,org.spongycastle.crypto.params.KeyParameter)">incrementPaymentBy</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="PaymentChannelClientState.IncrementedPayment.html" title="class in org.helixj.protocols.channels">PaymentChannelClientState.IncrementedPayment</a></span>&nbsp;<span class="memberName">incrementPaymentBy</span>&#8203;(<span class="arguments"><a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;size,
@Nullable
org.spongycastle.crypto.params.KeyParameter&nbsp;userKey)</span>
                                                                throws <span class="exceptions"><a href="ValueOutOfRangeException.html" title="class in org.helixj.protocols.channels">ValueOutOfRangeException</a></span></div>
<div class="block"><p>Updates the outputs on the payment contract transaction and re-signs it. The state must be READY in order to
 call this method. The signature that is returned should be sent to the server so it has the ability to broadcast
 the best seen payment when the channel closes or times out.</p>

 <p>The returned signature is over the payment transaction, which we never have a valid copy of and thus there
 is no accessor for it on this object.</p>

 <p>To spend the whole channel increment by <a href="PaymentChannelV1ClientState.html#getTotalValue()"><code>PaymentChannelV1ClientState.getTotalValue()</code></a> -
 <a href="#getValueRefunded()"><code>getValueRefunded()</code></a></p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>size</code> - How many satoshis to increment the payment by (note: not the new total).</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="ValueOutOfRangeException.html" title="class in org.helixj.protocols.channels">ValueOutOfRangeException</a></code> - If size is negative or the channel does not have sufficient money in it to
                                  complete this payment.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="updateChannelInWallet()">updateChannelInWallet</a></h3>
<div class="memberSignature"><span class="modifiers">protected</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">updateChannelInWallet</span>()</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="disconnectFromChannel()">disconnectFromChannel</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">disconnectFromChannel</span>()</div>
<div class="block">Sets this channel's state in <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a> to unopened so this channel can be reopened
 later.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#storeChannelInWallet(org.helixj.core.Sha256Hash)"><code>storeChannelInWallet(Sha256Hash)</code></a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="storeChannelInWallet(org.helixj.core.Sha256Hash)">storeChannelInWallet</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">storeChannelInWallet</span>&#8203;(<span class="arguments"><a href="../../core/Sha256Hash.html" title="class in org.helixj.core">Sha256Hash</a>&nbsp;id)</span></div>
<div class="block"><p>Stores this channel's state in the wallet as a part of a <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a> wallet
 extension and keeps it up-to-date each time payment is incremented. This allows the
 <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a> object to keep track of timeouts and broadcast the refund transaction
 when the channel expires.</p>

 <p>A channel may only be stored after it has fully opened (ie state == State.READY). The wallet provided in the
 constructor must already have a <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a> object in its extensions set.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - A hash providing this channel with an id which uniquely identifies this server. It does not have to be
           unique.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getRefundTxFees()">getRefundTxFees</a></h3>
<div class="memberSignature"><span class="modifiers">public abstract</span>&nbsp;<span class="returnType"><a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></span>&nbsp;<span class="memberName">getRefundTxFees</span>()</div>
<div class="block">Returns the fees that will be paid if the refund transaction has to be claimed because the server failed to settle
 the channel properly. May only be called after <a href="#initiate()"><code>initiate()</code></a></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getTotalValue()">getTotalValue</a></h3>
<div class="memberSignature"><span class="modifiers">public abstract</span>&nbsp;<span class="returnType"><a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></span>&nbsp;<span class="memberName">getTotalValue</span>()</div>
<div class="block">Gets the total value of this channel (ie the maximum payment possible)</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getValueRefunded()">getValueRefunded</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></span>&nbsp;<span class="memberName">getValueRefunded</span>()</div>
<div class="block">Gets the current amount refunded to us from the multisig contract (ie totalValue-valueSentToServer)</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getValueSpent()">getValueSpent</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></span>&nbsp;<span class="memberName">getValueSpent</span>()</div>
<div class="block">Returns the amount of money sent on this channel so far.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getValueToMe()">getValueToMe</a></h3>
<div class="memberSignature"><span class="modifiers">protected abstract</span>&nbsp;<span class="returnType"><a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></span>&nbsp;<span class="memberName">getValueToMe</span>()</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getExpiryTime()">getExpiryTime</a></h3>
<div class="memberSignature"><span class="modifiers">protected abstract</span>&nbsp;<span class="returnType">long</span>&nbsp;<span class="memberName">getExpiryTime</span>()</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getContractInternal()">getContractInternal</a></h3>
<div class="memberSignature"><span class="modifiers">protected abstract</span>&nbsp;<span class="returnType"><a href="../../core/Transaction.html" title="class in org.helixj.core">Transaction</a></span>&nbsp;<span class="memberName">getContractInternal</span>()</div>
<div class="block">Gets the contract without changing the state machine</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getContractScript()">getContractScript</a></h3>
<div class="memberSignature"><span class="modifiers">protected abstract</span>&nbsp;<span class="returnType"><a href="../../script/Script.html" title="class in org.helixj.script">Script</a></span>&nbsp;<span class="memberName">getContractScript</span>()</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getSignedScript()">getSignedScript</a></h3>
<div class="memberSignature"><span class="modifiers">protected abstract</span>&nbsp;<span class="returnType"><a href="../../script/Script.html" title="class in org.helixj.script">Script</a></span>&nbsp;<span class="memberName">getSignedScript</span>()</div>
<div class="block">Gets the script that is signed. In the case of a P2SH contract this is the
 script inside the P2SH script.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
