<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="fr">
<head>
<!-- Generated by javadoc -->
<title>PaymentChannelClient (core 0.15.8 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.helixj.protocols.channels, class: PaymentChannelClient">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.helixj.protocols.channels</a></div>
<h1 title="Class PaymentChannelClient" class="title">Class PaymentChannelClient</h1>
</div>
<div class="contentContainer">
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">org.helixj.protocols.channels.PaymentChannelClient</div>
</div>
<section class="description">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="IPaymentChannelClient.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient</a></code></dd>
</dl>
<hr>
<pre>public class <span class="typeNameLabel">PaymentChannelClient</span>
extends java.lang.Object
implements <a href="IPaymentChannelClient.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient</a></pre>
<div class="block"><p>A class which handles most of the complexity of creating a payment channel connection by providing a
 simple in/out interface which is provided with protobufs from the server and which generates protobufs which should
 be sent to the server.</p>

 <p>Does all required verification of server messages and properly stores state objects in the wallet-attached
 <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a> so that they are automatically closed when necessary and refund
 transactions are not lost if the application crashes before it unlocks.</p>

 <p>Though this interface is largely designed with stateful protocols (eg simple TCP connections) in mind, it is also
 possible to use it with stateless protocols (eg sending protobufs when required over HTTP headers). In this case, the
 "connection" translates roughly into the server-client relationship. See the javadocs for specific functions for more
 details.</p></div>
</section>
<section class="summary">
<ul class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li class="blockList">
<section class="nestedClassSummary"><a id="nested.class.summary">
<!--   -->
</a>
<h2>Nested Class Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="PaymentChannelClient.VersionSelector.html" title="enum in org.helixj.protocols.channels">PaymentChannelClient.VersionSelector</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<div class="inheritedList">
<h2>Nested classes/interfaces inherited from interface&nbsp;org.helixj.protocols.channels.<a href="IPaymentChannelClient.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient</a></h2>
<a id="nested.classes.inherited.from.class.org.helixj.protocols.channels.IPaymentChannelClient">
<!--   -->
</a><code><a href="IPaymentChannelClient.ClientConnection.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient.ClientConnection</a>, <a href="IPaymentChannelClient.Factory.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient.Factory</a></code></div>
</section>
</li>
<!-- =========== FIELD SUMMARY =========== -->
<li class="blockList">
<section class="fieldSummary"><a id="field.summary">
<!--   -->
</a>
<h2>Field Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#DEFAULT_TIME_WINDOW">DEFAULT_TIME_WINDOW</a></span></code></th>
<td class="colLast">
<div class="block">The default maximum amount of time for which we will accept the server locking up our funds for the multisig
 contract.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.concurrent.locks.ReentrantLock</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lock">lock</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li class="blockList">
<section class="constructorSummary"><a id="constructor.summary">
<!--   -->
</a>
<h2>Constructor Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(org.helixj.wallet.Wallet,org.helixj.core.ECKey,org.helixj.core.Coin,org.helixj.core.Sha256Hash,long,org.spongycastle.crypto.params.KeyParameter,org.helixj.protocols.channels.IPaymentChannelClient.ClientConnection)">PaymentChannelClient</a></span>&#8203;(<a href="../../wallet/Wallet.html" title="class in org.helixj.wallet">Wallet</a>&nbsp;wallet,
<a href="../../core/ECKey.html" title="class in org.helixj.core">ECKey</a>&nbsp;myKey,
<a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;maxValue,
<a href="../../core/Sha256Hash.html" title="class in org.helixj.core">Sha256Hash</a>&nbsp;serverId,
long&nbsp;timeWindow,
org.spongycastle.crypto.params.KeyParameter&nbsp;userKeySetup,
<a href="IPaymentChannelClient.ClientConnection.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient.ClientConnection</a>&nbsp;conn)</code></th>
<td class="colLast">
<div class="block">Constructs a new channel manager which waits for <a href="#connectionOpen()"><code>connectionOpen()</code></a> before acting.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(org.helixj.wallet.Wallet,org.helixj.core.ECKey,org.helixj.core.Coin,org.helixj.core.Sha256Hash,long,org.spongycastle.crypto.params.KeyParameter,org.helixj.protocols.channels.IPaymentChannelClient.ClientConnection,org.helixj.protocols.channels.PaymentChannelClient.VersionSelector)">PaymentChannelClient</a></span>&#8203;(<a href="../../wallet/Wallet.html" title="class in org.helixj.wallet">Wallet</a>&nbsp;wallet,
<a href="../../core/ECKey.html" title="class in org.helixj.core">ECKey</a>&nbsp;myKey,
<a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;maxValue,
<a href="../../core/Sha256Hash.html" title="class in org.helixj.core">Sha256Hash</a>&nbsp;serverId,
long&nbsp;timeWindow,
org.spongycastle.crypto.params.KeyParameter&nbsp;userKeySetup,
<a href="IPaymentChannelClient.ClientConnection.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient.ClientConnection</a>&nbsp;conn,
<a href="PaymentChannelClient.VersionSelector.html" title="enum in org.helixj.protocols.channels">PaymentChannelClient.VersionSelector</a>&nbsp;versionSelector)</code></th>
<td class="colLast">
<div class="block">Constructs a new channel manager which waits for <a href="#connectionOpen()"><code>connectionOpen()</code></a> before acting.</div>
</td>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(org.helixj.wallet.Wallet,org.helixj.core.ECKey,org.helixj.core.Coin,org.helixj.core.Sha256Hash,org.helixj.protocols.channels.IPaymentChannelClient.ClientConnection)">PaymentChannelClient</a></span>&#8203;(<a href="../../wallet/Wallet.html" title="class in org.helixj.wallet">Wallet</a>&nbsp;wallet,
<a href="../../core/ECKey.html" title="class in org.helixj.core">ECKey</a>&nbsp;myKey,
<a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;maxValue,
<a href="../../core/Sha256Hash.html" title="class in org.helixj.core">Sha256Hash</a>&nbsp;serverId,
<a href="IPaymentChannelClient.ClientConnection.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient.ClientConnection</a>&nbsp;conn)</code></th>
<td class="colLast">
<div class="block">Constructs a new channel manager which waits for <a href="#connectionOpen()"><code>connectionOpen()</code></a> before acting.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(org.helixj.wallet.Wallet,org.helixj.core.ECKey,org.helixj.core.Coin,org.helixj.core.Sha256Hash,org.helixj.protocols.channels.IPaymentChannelClient.ClientConnection,org.helixj.protocols.channels.PaymentChannelClient.VersionSelector)">PaymentChannelClient</a></span>&#8203;(<a href="../../wallet/Wallet.html" title="class in org.helixj.wallet">Wallet</a>&nbsp;wallet,
<a href="../../core/ECKey.html" title="class in org.helixj.core">ECKey</a>&nbsp;myKey,
<a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;maxValue,
<a href="../../core/Sha256Hash.html" title="class in org.helixj.core">Sha256Hash</a>&nbsp;serverId,
<a href="IPaymentChannelClient.ClientConnection.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient.ClientConnection</a>&nbsp;conn,
<a href="PaymentChannelClient.VersionSelector.html" title="enum in org.helixj.protocols.channels">PaymentChannelClient.VersionSelector</a>&nbsp;versionSelector)</code></th>
<td class="colLast">
<div class="block">Constructs a new channel manager which waits for <a href="#connectionOpen()"><code>connectionOpen()</code></a> before acting.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="tableTab" onclick="show(8);">Concrete Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#connectionClosed()">connectionClosed</a></span>()</code></th>
<td class="colLast">
<div class="block">Called when the connection terminates.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#connectionOpen()">connectionOpen</a></span>()</code></th>
<td class="colLast">
<div class="block">Called to indicate the connection has been opened and messages can now be generated for the server.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code><a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMissing()">getMissing</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the amount of satoshis missing when a server requests too much value.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>com.google.common.util.concurrent.ListenableFuture&lt;<a href="PaymentIncrementAck.html" title="class in org.helixj.protocols.channels">PaymentIncrementAck</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#incrementPayment(org.helixj.core.Coin)">incrementPayment</a></span>&#8203;(<a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;size)</code></th>
<td class="colLast">
<div class="block">Increments the total value which we pay the server.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>com.google.common.util.concurrent.ListenableFuture&lt;<a href="PaymentIncrementAck.html" title="class in org.helixj.protocols.channels">PaymentIncrementAck</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#incrementPayment(org.helixj.core.Coin,com.google.protobuf.ByteString,org.spongycastle.crypto.params.KeyParameter)">incrementPayment</a></span>&#8203;(<a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;size,
com.google.protobuf.ByteString&nbsp;info,
org.spongycastle.crypto.params.KeyParameter&nbsp;userKey)</code></th>
<td class="colLast">
<div class="block">Increments the total value which we pay the server.</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#receiveMessage(org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage)">receiveMessage</a></span>&#8203;(<a href="../../../bitcoin/paymentchannel/Protos.TwoWayChannelMessage.html" title="class in org.bitcoin.paymentchannel">Protos.TwoWayChannelMessage</a>&nbsp;msg)</code></th>
<td class="colLast">
<div class="block">Called when a message is received from the server.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#settle()">settle</a></span>()</code></th>
<td class="colLast">
<div class="block">Closes the connection, notifying the server it should settle the channel by broadcasting the most recent
 payment transaction.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code><a href="PaymentChannelClientState.html" title="class in org.helixj.protocols.channels">PaymentChannelClientState</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#state()">state</a></span>()</code></th>
<td class="colLast">
<div class="block">Gets the <a href="PaymentChannelClientState.html" title="class in org.helixj.protocols.channels"><code>PaymentChannelClientState</code></a> object which stores the current state of the connection with the
 server.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inheritedList">
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a><code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<li class="blockList">
<section class="fieldDetails"><a id="field.detail">
<!--   -->
</a>
<h2>Field Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="lock">lock</a></h3>
<div class="memberSignature"><span class="modifiers">protected final</span>&nbsp;<span class="returnType">java.util.concurrent.locks.ReentrantLock</span>&nbsp;<span class="memberName">lock</span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="DEFAULT_TIME_WINDOW">DEFAULT_TIME_WINDOW</a></h3>
<div class="memberSignature"><span class="modifiers">public static final</span>&nbsp;<span class="returnType">long</span>&nbsp;<span class="memberName">DEFAULT_TIME_WINDOW</span></div>
<div class="block"><p>The default maximum amount of time for which we will accept the server locking up our funds for the multisig
 contract.</p>

 <p>24 hours less a minute  is the default as it is expected that clients limit risk exposure by limiting channel size instead of
 limiting lock time when dealing with potentially malicious servers.</p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#org.helixj.protocols.channels.PaymentChannelClient.DEFAULT_TIME_WINDOW">Constant Field Values</a></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li class="blockList">
<section class="constructorDetails"><a id="constructor.detail">
<!--   -->
</a>
<h2>Constructor Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="&lt;init&gt;(org.helixj.wallet.Wallet,org.helixj.core.ECKey,org.helixj.core.Coin,org.helixj.core.Sha256Hash,org.helixj.protocols.channels.IPaymentChannelClient.ClientConnection)">PaymentChannelClient</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="memberName">PaymentChannelClient</span>&#8203;(<span class="arguments"><a href="../../wallet/Wallet.html" title="class in org.helixj.wallet">Wallet</a>&nbsp;wallet,
<a href="../../core/ECKey.html" title="class in org.helixj.core">ECKey</a>&nbsp;myKey,
<a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;maxValue,
<a href="../../core/Sha256Hash.html" title="class in org.helixj.core">Sha256Hash</a>&nbsp;serverId,
<a href="IPaymentChannelClient.ClientConnection.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient.ClientConnection</a>&nbsp;conn)</span></div>
<div class="block">Constructs a new channel manager which waits for <a href="#connectionOpen()"><code>connectionOpen()</code></a> before acting.
 A default time window of <a href="#DEFAULT_TIME_WINDOW"><code>DEFAULT_TIME_WINDOW</code></a> will be used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>wallet</code> - The wallet which will be paid from, and where completed transactions will be committed.
               Must already have a <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a> object in its extensions set.</dd>
<dd><code>myKey</code> - A freshly generated keypair used for the multisig contract and refund output.</dd>
<dd><code>maxValue</code> - The maximum value the server is allowed to request that we lock into this channel until the
                 refund transaction unlocks. Note that if there is a previously open channel, the refund
                 transaction used in this channel may be larger than maxValue. Thus, maxValue is not a method for
                 limiting the amount payable through this channel.</dd>
<dd><code>serverId</code> - An arbitrary hash representing this channel. This must uniquely identify the server. If an
                 existing stored channel exists in the wallet's <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a>, then an
                 attempt will be made to resume that channel.</dd>
<dd><code>conn</code> - A callback listener which represents the connection to the server (forwards messages we generate to
             the server)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="&lt;init&gt;(org.helixj.wallet.Wallet,org.helixj.core.ECKey,org.helixj.core.Coin,org.helixj.core.Sha256Hash,org.helixj.protocols.channels.IPaymentChannelClient.ClientConnection,org.helixj.protocols.channels.PaymentChannelClient.VersionSelector)">PaymentChannelClient</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="memberName">PaymentChannelClient</span>&#8203;(<span class="arguments"><a href="../../wallet/Wallet.html" title="class in org.helixj.wallet">Wallet</a>&nbsp;wallet,
<a href="../../core/ECKey.html" title="class in org.helixj.core">ECKey</a>&nbsp;myKey,
<a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;maxValue,
<a href="../../core/Sha256Hash.html" title="class in org.helixj.core">Sha256Hash</a>&nbsp;serverId,
<a href="IPaymentChannelClient.ClientConnection.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient.ClientConnection</a>&nbsp;conn,
<a href="PaymentChannelClient.VersionSelector.html" title="enum in org.helixj.protocols.channels">PaymentChannelClient.VersionSelector</a>&nbsp;versionSelector)</span></div>
<div class="block">Constructs a new channel manager which waits for <a href="#connectionOpen()"><code>connectionOpen()</code></a> before acting.
 A default time window of <a href="#DEFAULT_TIME_WINDOW"><code>DEFAULT_TIME_WINDOW</code></a> will be used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>wallet</code> - The wallet which will be paid from, and where completed transactions will be committed.
               Must already have a <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a> object in its extensions set.</dd>
<dd><code>myKey</code> - A freshly generated keypair used for the multisig contract and refund output.</dd>
<dd><code>maxValue</code> - The maximum value the server is allowed to request that we lock into this channel until the
                 refund transaction unlocks. Note that if there is a previously open channel, the refund
                 transaction used in this channel may be larger than maxValue. Thus, maxValue is not a method for
                 limiting the amount payable through this channel.</dd>
<dd><code>serverId</code> - An arbitrary hash representing this channel. This must uniquely identify the server. If an
                 existing stored channel exists in the wallet's <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a>, then an
                 attempt will be made to resume that channel.</dd>
<dd><code>conn</code> - A callback listener which represents the connection to the server (forwards messages we generate to
             the server)</dd>
<dd><code>versionSelector</code> - An enum indicating which versions to support:
                        VERSION_1: use only version 1 of the protocol
                        VERSION_2_ALLOW_1: suggest version 2 but allow downgrade to version 1
                        VERSION_2: suggest version 2 and enforce use of version 2</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="&lt;init&gt;(org.helixj.wallet.Wallet,org.helixj.core.ECKey,org.helixj.core.Coin,org.helixj.core.Sha256Hash,long,org.spongycastle.crypto.params.KeyParameter,org.helixj.protocols.channels.IPaymentChannelClient.ClientConnection)">PaymentChannelClient</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="memberName">PaymentChannelClient</span>&#8203;(<span class="arguments"><a href="../../wallet/Wallet.html" title="class in org.helixj.wallet">Wallet</a>&nbsp;wallet,
<a href="../../core/ECKey.html" title="class in org.helixj.core">ECKey</a>&nbsp;myKey,
<a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;maxValue,
<a href="../../core/Sha256Hash.html" title="class in org.helixj.core">Sha256Hash</a>&nbsp;serverId,
long&nbsp;timeWindow,
@Nullable
org.spongycastle.crypto.params.KeyParameter&nbsp;userKeySetup,
<a href="IPaymentChannelClient.ClientConnection.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient.ClientConnection</a>&nbsp;conn)</span></div>
<div class="block">Constructs a new channel manager which waits for <a href="#connectionOpen()"><code>connectionOpen()</code></a> before acting.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>wallet</code> - The wallet which will be paid from, and where completed transactions will be committed.
               Must already have a <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a> object in its extensions set.</dd>
<dd><code>myKey</code> - A freshly generated keypair used for the multisig contract and refund output.</dd>
<dd><code>maxValue</code> - The maximum value the server is allowed to request that we lock into this channel until the
                 refund transaction unlocks. Note that if there is a previously open channel, the refund
                 transaction used in this channel may be larger than maxValue. Thus, maxValue is not a method for
                 limiting the amount payable through this channel.</dd>
<dd><code>serverId</code> - An arbitrary hash representing this channel. This must uniquely identify the server. If an
                 existing stored channel exists in the wallet's <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a>, then an
                 attempt will be made to resume that channel.</dd>
<dd><code>timeWindow</code> - The time in seconds, relative to now, on how long this channel should be kept open. Note that is is
                   a proposal to the server. The server may in turn propose something different.
                   See <a href="IPaymentChannelClient.ClientConnection.html#acceptExpireTime(long)"><code>IPaymentChannelClient.ClientConnection.acceptExpireTime(long)</code></a></dd>
<dd><code>userKeySetup</code> - Key derived from a user password, used to decrypt myKey, if it is encrypted, during setup.</dd>
<dd><code>conn</code> - A callback listener which represents the connection to the server (forwards messages we generate to
             the server)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="&lt;init&gt;(org.helixj.wallet.Wallet,org.helixj.core.ECKey,org.helixj.core.Coin,org.helixj.core.Sha256Hash,long,org.spongycastle.crypto.params.KeyParameter,org.helixj.protocols.channels.IPaymentChannelClient.ClientConnection,org.helixj.protocols.channels.PaymentChannelClient.VersionSelector)">PaymentChannelClient</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="memberName">PaymentChannelClient</span>&#8203;(<span class="arguments"><a href="../../wallet/Wallet.html" title="class in org.helixj.wallet">Wallet</a>&nbsp;wallet,
<a href="../../core/ECKey.html" title="class in org.helixj.core">ECKey</a>&nbsp;myKey,
<a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;maxValue,
<a href="../../core/Sha256Hash.html" title="class in org.helixj.core">Sha256Hash</a>&nbsp;serverId,
long&nbsp;timeWindow,
@Nullable
org.spongycastle.crypto.params.KeyParameter&nbsp;userKeySetup,
<a href="IPaymentChannelClient.ClientConnection.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient.ClientConnection</a>&nbsp;conn,
<a href="PaymentChannelClient.VersionSelector.html" title="enum in org.helixj.protocols.channels">PaymentChannelClient.VersionSelector</a>&nbsp;versionSelector)</span></div>
<div class="block">Constructs a new channel manager which waits for <a href="#connectionOpen()"><code>connectionOpen()</code></a> before acting.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>wallet</code> - The wallet which will be paid from, and where completed transactions will be committed.
               Must already have a <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a> object in its extensions set.</dd>
<dd><code>myKey</code> - A freshly generated keypair used for the multisig contract and refund output.</dd>
<dd><code>maxValue</code> - The maximum value the server is allowed to request that we lock into this channel until the
                 refund transaction unlocks. Note that if there is a previously open channel, the refund
                 transaction used in this channel may be larger than maxValue. Thus, maxValue is not a method for
                 limiting the amount payable through this channel.</dd>
<dd><code>serverId</code> - An arbitrary hash representing this channel. This must uniquely identify the server. If an
                 existing stored channel exists in the wallet's <a href="StoredPaymentChannelClientStates.html" title="class in org.helixj.protocols.channels"><code>StoredPaymentChannelClientStates</code></a>, then an
                 attempt will be made to resume that channel.</dd>
<dd><code>timeWindow</code> - The time in seconds, relative to now, on how long this channel should be kept open. Note that is is
                   a proposal to the server. The server may in turn propose something different.
                   See <a href="IPaymentChannelClient.ClientConnection.html#acceptExpireTime(long)"><code>IPaymentChannelClient.ClientConnection.acceptExpireTime(long)</code></a></dd>
<dd><code>userKeySetup</code> - Key derived from a user password, used to decrypt myKey, if it is encrypted, during setup.</dd>
<dd><code>conn</code> - A callback listener which represents the connection to the server (forwards messages we generate to
             the server)</dd>
<dd><code>versionSelector</code> - An enum indicating which versions to support:
                        VERSION_1: use only version 1 of the protocol
                        VERSION_2_ALLOW_1: suggest version 2 but allow downgrade to version 1
                        VERSION_2: suggest version 2 and enforce use of version 2</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="getMissing()">getMissing</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a></span>&nbsp;<span class="memberName">getMissing</span>()</div>
<div class="block"><p>Returns the amount of satoshis missing when a server requests too much value.</p>

 <p>When InsufficientMoneyException is thrown due to the server requesting too much value, an instance of 
 PaymentChannelClient needs access to how many satoshis are missing.</p></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="receiveMessage(org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage)">receiveMessage</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">receiveMessage</span>&#8203;(<span class="arguments"><a href="../../../bitcoin/paymentchannel/Protos.TwoWayChannelMessage.html" title="class in org.bitcoin.paymentchannel">Protos.TwoWayChannelMessage</a>&nbsp;msg)</span>
                    throws <span class="exceptions"><a href="../../core/InsufficientMoneyException.html" title="class in org.helixj.core">InsufficientMoneyException</a></span></div>
<div class="block">Called when a message is received from the server. Processes the given message and generates events based on its
 content.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="IPaymentChannelClient.html#receiveMessage(org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage)">receiveMessage</a></code>&nbsp;in interface&nbsp;<code><a href="IPaymentChannelClient.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient</a></code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../core/InsufficientMoneyException.html" title="class in org.helixj.core">InsufficientMoneyException</a></code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="connectionClosed()">connectionClosed</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">connectionClosed</span>()</div>
<div class="block"><p>Called when the connection terminates. Notifies the <code>StoredClientChannel</code> object that we can attempt to
 resume this channel in the future and stops generating messages for the server.</p>

 <p>For stateless protocols, this translates to a client not using the channel for the immediate future, but
 intending to reopen the channel later. There is likely little reason to use this in a stateless protocol.</p>

 <p>Note that this <b>MUST</b> still be called even after either
 <a href="IPaymentChannelClient.ClientConnection.html#destroyConnection(org.helixj.protocols.channels.PaymentChannelCloseException.CloseReason)"><code>IPaymentChannelClient.ClientConnection.destroyConnection(org.helixj.protocols.channels.PaymentChannelCloseException.CloseReason)</code></a> or
 <a href="#settle()"><code>settle()</code></a> is called, to actually handle the connection close logic.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="IPaymentChannelClient.html#connectionClosed()">connectionClosed</a></code>&nbsp;in interface&nbsp;<code><a href="IPaymentChannelClient.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient</a></code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="settle()">settle</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">settle</span>()
            throws <span class="exceptions">java.lang.IllegalStateException</span></div>
<div class="block"><p>Closes the connection, notifying the server it should settle the channel by broadcasting the most recent
 payment transaction.</p>

 <p>Note that this only generates a CLOSE message for the server and calls
 <a href="IPaymentChannelClient.ClientConnection.html#destroyConnection(org.helixj.protocols.channels.PaymentChannelCloseException.CloseReason)"><code>IPaymentChannelClient.ClientConnection.destroyConnection(CloseReason)</code></a> to settle the connection, it does not
 actually handle connection close logic, and <a href="#connectionClosed()"><code>connectionClosed()</code></a> must still be called
 after the connection fully closes.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="IPaymentChannelClient.html#settle()">settle</a></code>&nbsp;in interface&nbsp;<code><a href="IPaymentChannelClient.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient</a></code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - If the connection is not currently open (ie the CLOSE message cannot be sent)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="connectionOpen()">connectionOpen</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">connectionOpen</span>()</div>
<div class="block"><p>Called to indicate the connection has been opened and messages can now be generated for the server.</p>

 <p>Attempts to find a channel to resume and generates a CLIENT_VERSION message for the server based on the
 result.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="IPaymentChannelClient.html#connectionOpen()">connectionOpen</a></code>&nbsp;in interface&nbsp;<code><a href="IPaymentChannelClient.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient</a></code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="state()">state</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="PaymentChannelClientState.html" title="class in org.helixj.protocols.channels">PaymentChannelClientState</a></span>&nbsp;<span class="memberName">state</span>()</div>
<div class="block"><p>Gets the <a href="PaymentChannelClientState.html" title="class in org.helixj.protocols.channels"><code>PaymentChannelClientState</code></a> object which stores the current state of the connection with the
 server.</p>

 <p>Note that if you call any methods which update state directly the server will not be notified and channel
 initialization logic in the connection may fail unexpectedly.</p></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="incrementPayment(org.helixj.core.Coin)">incrementPayment</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">com.google.common.util.concurrent.ListenableFuture&lt;<a href="PaymentIncrementAck.html" title="class in org.helixj.protocols.channels">PaymentIncrementAck</a>&gt;</span>&nbsp;<span class="memberName">incrementPayment</span>&#8203;(<span class="arguments"><a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;size)</span>
                                                                                         throws <span class="exceptions"><a href="ValueOutOfRangeException.html" title="class in org.helixj.protocols.channels">ValueOutOfRangeException</a>,
java.lang.IllegalStateException</span></div>
<div class="block">Increments the total value which we pay the server. Note that the amount of money sent may not be the same as the
 amount of money actually requested. It can be larger if the amount left over in the channel would be too small to
 be accepted by the Bitcoin network. ValueOutOfRangeException will be thrown, however, if there's not enough money
 left in the channel to make the payment at all. Only one payment can be in-flight at once. You have to ensure
 you wait for the previous increase payment future to complete before incrementing the payment again.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>size</code> - How many satoshis to increment the payment by (note: not the new total).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a future that completes when the server acknowledges receipt and acceptance of the payment.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="ValueOutOfRangeException.html" title="class in org.helixj.protocols.channels">ValueOutOfRangeException</a></code> - If the size is negative or would pay more than this channel's total value
                                  (<a href="PaymentChannelClientConnection.html#state()"><code>PaymentChannelClientConnection.state()</code></a>.getTotalValue())</dd>
<dd><code>java.lang.IllegalStateException</code> - If the channel has been closed or is not yet open
                               (see <a href="PaymentChannelClientConnection.html#getChannelOpenFuture()"><code>PaymentChannelClientConnection.getChannelOpenFuture()</code></a> for the second)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="incrementPayment(org.helixj.core.Coin,com.google.protobuf.ByteString,org.spongycastle.crypto.params.KeyParameter)">incrementPayment</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">com.google.common.util.concurrent.ListenableFuture&lt;<a href="PaymentIncrementAck.html" title="class in org.helixj.protocols.channels">PaymentIncrementAck</a>&gt;</span>&nbsp;<span class="memberName">incrementPayment</span>&#8203;(<span class="arguments"><a href="../../core/Coin.html" title="class in org.helixj.core">Coin</a>&nbsp;size,
@Nullable
com.google.protobuf.ByteString&nbsp;info,
@Nullable
org.spongycastle.crypto.params.KeyParameter&nbsp;userKey)</span>
                                                                                         throws <span class="exceptions"><a href="ValueOutOfRangeException.html" title="class in org.helixj.protocols.channels">ValueOutOfRangeException</a>,
java.lang.IllegalStateException,
<a href="../../core/ECKey.KeyIsEncryptedException.html" title="class in org.helixj.core">ECKey.KeyIsEncryptedException</a></span></div>
<div class="block">Increments the total value which we pay the server. Note that the amount of money sent may not be the same as the
 amount of money actually requested. It can be larger if the amount left over in the channel would be too small to
 be accepted by the Bitcoin network. ValueOutOfRangeException will be thrown, however, if there's not enough money
 left in the channel to make the payment at all. Only one payment can be in-flight at once. You have to ensure
 you wait for the previous increase payment future to complete before incrementing the payment again.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="IPaymentChannelClient.html#incrementPayment(org.helixj.core.Coin,com.google.protobuf.ByteString,org.spongycastle.crypto.params.KeyParameter)">incrementPayment</a></code>&nbsp;in interface&nbsp;<code><a href="IPaymentChannelClient.html" title="interface in org.helixj.protocols.channels">IPaymentChannelClient</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>size</code> - How many satoshis to increment the payment by (note: not the new total).</dd>
<dd><code>info</code> - Information about this update, used to extend this protocol.</dd>
<dd><code>userKey</code> - Key derived from a user password, needed for any signing when the wallet is encrypted.
                The wallet KeyCrypter is assumed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a future that completes when the server acknowledges receipt and acceptance of the payment.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="ValueOutOfRangeException.html" title="class in org.helixj.protocols.channels">ValueOutOfRangeException</a></code> - If the size is negative or would pay more than this channel's total value
                                  (<a href="PaymentChannelClientConnection.html#state()"><code>PaymentChannelClientConnection.state()</code></a>.getTotalValue())</dd>
<dd><code>java.lang.IllegalStateException</code> - If the channel has been closed or is not yet open
                               (see <a href="PaymentChannelClientConnection.html#getChannelOpenFuture()"><code>PaymentChannelClientConnection.getChannelOpenFuture()</code></a> for the second)</dd>
<dd><code><a href="../../core/ECKey.KeyIsEncryptedException.html" title="class in org.helixj.core">ECKey.KeyIsEncryptedException</a></code> - If the keys are encrypted and no AES key has been provided,</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
